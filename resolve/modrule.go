package resolve

import (
	"fmt"
	"github.com/bazelbuild/bzlmod/common"
	"github.com/bazelbuild/bzlmod/common/starutil"
	"github.com/bazelbuild/bzlmod/lockfile"
	"github.com/bazelbuild/bzlmod/modrule"
	"go.starlark.net/starlark"
	"log"
)

func runModuleRules(ctx *context) error {
	// Group all tags by the key of the module rule and then the ruleset name.
	tagsByKeyAndRuleset := make(map[common.ModuleKey]map[string][]*modrule.Tag)
	for _, module := range ctx.depGraph {
		for idx := range module.Tags {
			tag := &module.Tags[idx]
			tagsByRuleset, ok := tagsByKeyAndRuleset[tag.ModuleKey]
			if !ok {
				tagsByRuleset = make(map[string][]*modrule.Tag)
				tagsByKeyAndRuleset[tag.ModuleKey] = tagsByRuleset
			}
			tagsByRuleset[tag.RulesetName] = append(tagsByRuleset[tag.RulesetName], tag)
		}
	}

	// For each module whose exported module rules are invoked, we evaluate its module rule exports, and then call the
	// resolve_fn of any invoked module rulesets, storing the ResolveResult for the next step.
	eval := modrule.NewEval(ctx.lfWorkspace)
	type keyAndRulesetName struct {
		key         common.ModuleKey
		rulesetName string
	}
	type rulesetResolveResult struct {
		resolveResult     *modrule.ResolveResult
		infoHolderPerRepo map[string]*starutil.ValueHolder
		ruleset           *modrule.Ruleset
	}
	resultStorage := make(map[keyAndRulesetName]rulesetResolveResult)
	for key, tagsByRuleset := range tagsByKeyAndRuleset {
		module := ctx.depGraph[key]
		rulesets, err := eval.ExecForRulesets(key, module.RepoName, module.ModuleRuleExports)
		if err != nil {
			return err
		}
		// Report any undefined rulesets early, before we actually call any resolve_fn.
		for rulesetName, tags := range tagsByRuleset {
			if _, ok := rulesets[rulesetName]; ok {
				continue
			}
			log.Printf("%v: module %v does not export a ruleset named %q\n", tags[0].Pos, key, rulesetName)
			err = fmt.Errorf("undefined ruleset")
		}
		if err != nil {
			return err
		}
		// Now invoke the resolve fn of any invoked rulesets.
		for rulesetName := range tagsByRuleset {
			ruleset := rulesets[rulesetName]
			resolveResult, err := callResolveFn(ruleset, ctx.depGraph, ctx.rootModuleName)
			if err != nil {
				return err
			}
			infoHolderPerRepo := make(map[string]*starutil.ValueHolder)
			resultStorage[keyAndRulesetName{key, rulesetName}] = rulesetResolveResult{
				resolveResult:     resolveResult,
				infoHolderPerRepo: infoHolderPerRepo,
				ruleset:           ruleset,
			}
			// Repo unserializable repo infos early, before we actually process all resolve results.
			for repoName, repoInfo := range resolveResult.Repos {
				infoHolderPerRepo[repoName], err = starutil.NewValueHolder(repoInfo)
				if err != nil {
					return fmt.Errorf("repo info for repo %v is not serializable: %v", repoName, err)
				}
			}
		}
	}

	// Now we need to update the lockfile workspace with the resolution results. First, we create the repos for each
	// ResolveResult.
	for keyAndRulesetName, rulesetResolveResult := range resultStorage {
		key := keyAndRulesetName.key
		rulesetName := keyAndRulesetName.rulesetName
		module := ctx.depGraph[keyAndRulesetName.key]
		resolveResult := rulesetResolveResult.resolveResult
		ruleset := rulesetResolveResult.ruleset
		for repoName := range resolveResult.Repos {
			repo := lockfile.NewRepo()
			infoHolder := rulesetResolveResult.infoHolderPerRepo[repoName]
			// Each repo created by module rules defined by module X can use all of X's bazel_deps.
			for depRepoName, actualRepoName := range ctx.lfWorkspace.Repos[module.RepoName].Deps {
				repo.Deps[depRepoName] = actualRepoName
			}
			// All repos generated by the same module ruleset can use each other.
			for depRepoName, _ := range resolveResult.Repos {
				if depRepoName != repoName {
					repo.Deps[depRepoName] = depRepoName
				}
			}
			repo.Fetcher = lockfile.WrapFetcher(&modrule.Fetcher{
				DefModuleKey:      key,
				DefRepoName:       module.RepoName,
				ModuleRuleExports: module.ModuleRuleExports,
				RulesetName:       rulesetName,
				RepoInfo:          infoHolder,
				MachineSpecific:   ruleset.MachineSpecific,
				Fprint:            common.Hash("moduleRuleRepo", key, rulesetName, infoHolder.Serialized),
			})
			ctx.lfWorkspace.Repos[repoName] = repo
		}
		ctx.lfWorkspace.Toolchains = append(ctx.lfWorkspace.Toolchains, resolveResult.Toolchains...)
		ctx.lfWorkspace.ExecPlatforms = append(ctx.lfWorkspace.ExecPlatforms, resolveResult.ExecPlatforms...)
	}
	// Now, we update the repo_deps of all Bazel modules that invoked any module rules, to include all the repos
	// generated by the invoked module rules.
	for _, module := range ctx.depGraph {
		invokedModuleRules := make(map[keyAndRulesetName]bool)
		repo := ctx.lfWorkspace.Repos[module.RepoName]
		for idx := range module.Tags {
			invokedModuleRules[keyAndRulesetName{module.Tags[idx].ModuleKey, module.Tags[idx].RulesetName}] = true
		}
		for invokedModuleRule := range invokedModuleRules {
			resolveResult := resultStorage[invokedModuleRule].resolveResult
			for genRepoName := range resolveResult.Repos {
				repo.Deps[genRepoName] = genRepoName
			}
		}
	}

	return nil
}

func callResolveFn(ruleset *modrule.Ruleset, depGraph DepGraph, rootModuleName string) (*modrule.ResolveResult, error) {
	topModule, err := buildTopModule(ruleset, depGraph, rootModuleName)
	if err != nil {
		return nil, err
	}
	thread := &starlark.Thread{
		Name: fmt.Sprintf("resolve_fn of %v in %v", ruleset.Name, ruleset.ModuleKey),
	}
	ctx := modrule.NewResolveContext(topModule)
	result, err := starlark.Call(thread, ruleset.ResolveFn, []starlark.Value{ctx}, nil)
	if err != nil {
		log.Printf("%v: %v", thread.CallFrame(0).Pos, err)
		return nil, fmt.Errorf("error running %v: %v", thread.Name, err)
	}
	rr, ok := result.(*modrule.ResolveResult)
	if !ok {
		log.Printf("%v: expected return value of type ResolveResult, got: %v", ruleset.ResolveFn.Position(), result)
		return nil, fmt.Errorf("resolve_fn did not return a ResolveResult object")
	}
	return rr, nil
}

func buildTopModule(ruleset *modrule.Ruleset, depGraph DepGraph, rootModuleName string) (*modrule.BazelModule, error) {
	bazelModuleMap := make(map[common.ModuleKey]*modrule.BazelModule)
	for key, module := range depGraph {
		bazelModule := &modrule.BazelModule{
			Name:          starlark.String(module.Key.Name),
			Version:       starlark.String(module.Key.Version),
			RuleInstances: modrule.NewRuleInstances(),
		}
		bazelModuleMap[key] = bazelModule
		for _, tag := range module.Tags {
			// Filter tags down to those that belong to this ruleset.
			if tag.ModuleKey != ruleset.ModuleKey || tag.RulesetName != ruleset.Name {
				continue
			}
			rule := ruleset.Members[tag.RuleName]
			if rule == nil {
				log.Printf("%v: ruleset %v in module %v has no member rule named %q\n", tag.Pos, tag.RulesetName, tag.ModuleKey, tag.RuleName)
				return nil, fmt.Errorf("undefined rule")
			}
			ruleInstance, err := modrule.NewRuleInstance(rule, tag.Kwargs)
			if err != nil {
				log.Printf("%v: %v", tag.Pos, err)
				return nil, fmt.Errorf("error creating rule instance")
			}
			bazelModule.RuleInstances.Append(tag.RuleName, ruleInstance)
		}
	}
	for key, module := range depGraph {
		bazelModule := bazelModuleMap[key]
		for _, depKey := range module.Deps {
			bazelModule.BazelDeps = append(bazelModule.BazelDeps, bazelModuleMap[depKey])
		}
	}
	return bazelModuleMap[common.ModuleKey{rootModuleName, ""}], nil
}
