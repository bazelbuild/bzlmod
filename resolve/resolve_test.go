package resolve

import (
	"github.com/bazelbuild/bzlmod/common/testutil"
	"github.com/bazelbuild/bzlmod/fetch"
	"github.com/bazelbuild/bzlmod/registry"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"io/ioutil"
	"path/filepath"
	"testing"
)

func TestRepoNames(t *testing.T) {
	wsDir := t.TempDir()
	testutil.WriteFile(t, filepath.Join(wsDir, "MODULE.bazel"), `
module(name="A")
bazel_dep(name="B", version="1.0", repo_name="BfromA")
bazel_dep(name="C", version="2.0")
bazel_dep(name="E", version="3.0", repo_name="EfromA")
`)
	reg := registry.NewFake("fake")
	reg.AddModule(t, "B", "1.0", `
module(name="B", version="1.0")
bazel_dep(name="D", version="0.1", repo_name="DfromB")
`, &fetch.LocalPath{"B/1.0"})
	reg.AddModule(t, "C", "2.0", `
module(name="C", version="2.0")
bazel_dep(name="D", version="0.2", repo_name="DfromC")
`, &fetch.LocalPath{"C/1.0"})
	reg.AddModule(t, "D", "0.1", `
module(name="D", version="0.1")
bazel_dep(name="F", version="10.0")
`, &fetch.LocalPath{"D/0.1"})
	reg.AddModule(t, "D", "0.2", `
module(name="D", version="0.2")
bazel_dep(name="E", version="2.0")
`, &fetch.LocalPath{"D/0.2"})
	reg.AddModule(t, "E", "2.0", `
module(name="E", version="2.0")
`, &fetch.LocalPath{"E/2.0"})
	reg.AddModule(t, "E", "3.0", `
module(name="E", version="3.0")
`, &fetch.LocalPath{"E/3.0"})
	reg.AddModule(t, "F", "10.0", `
module(name="F", version="10.0")
`, &fetch.LocalPath{"F/10.0"})

	require.NoError(t, Resolve(wsDir, []string{reg.URL()}))

	lockFile, err := ioutil.ReadFile(filepath.Join(wsDir, "bzlmod.lock"))
	if assert.NoError(t, err) {
		const expectedLockFile = `{
  "VendorDir": "",
  "Repos": {
    "BfromA": {
      "Fetcher": {
        "LocalPath": {
          "Path": "B/1.0"
        }
      }
    },
    "C": {
      "Fetcher": {
        "LocalPath": {
          "Path": "C/1.0"
        }
      }
    },
    "D": {
      "Fetcher": {
        "LocalPath": {
          "Path": "D/0.2"
        }
      }
    },
    "EfromA": {
      "Fetcher": {
        "LocalPath": {
          "Path": "E/3.0"
        }
      }
    }
  }
}`
		assert.Equal(t, expectedLockFile, string(lockFile))
	}

	ws, err := ioutil.ReadFile(filepath.Join(wsDir, "WORKSPACE"))
	if assert.NoError(t, err) {
		const expectedWs = `# This file is automatically generated by bzlmod
workspace(
    name = "A",
    watch_files = { "MODULE.bazel": "sha256-XU5Yl/tcf2SLNGrqlI2NeFpw9u31rdt2o8lywcjHTaE=" },
    refresh_command = ["bzlmod", "resolve"],
)

repo(
    name = "BfromA",
    fetch_command = ["bzlmod", "fetch", "BfromA"],
    fingerprint = "",
    repo_deps = {
        "DfromB": "D",
    },
)

repo(
    name = "C",
    fetch_command = ["bzlmod", "fetch", "C"],
    fingerprint = "",
    repo_deps = {
        "DfromC": "D",
    },
)

repo(
    name = "D",
    fetch_command = ["bzlmod", "fetch", "D"],
    fingerprint = "",
    repo_deps = {
        "E": "EfromA",
    },
)

repo(
    name = "EfromA",
    fetch_command = ["bzlmod", "fetch", "EfromA"],
    fingerprint = "",
)
`
		assert.Equal(t, expectedWs, string(ws))
	}
}
