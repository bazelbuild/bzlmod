package resolve

import (
	"encoding/json"
	"fmt"
	"github.com/bazelbuild/bzlmod/fetch"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
)

type context struct {
	rootModuleName string
	depGraph       DepGraph
	overrideSet    OverrideSet
}

func Resolve(wsDir string, registries []string) error {
	ctx, err := Discovery(wsDir, registries)
	if err != nil {
		return fmt.Errorf("error during discovery: %v", err)
	}
	if err = Selection(ctx); err != nil {
		return fmt.Errorf("error running selection: %v", err)
	}
	if err = fillModuleData(ctx); err != nil {
		return fmt.Errorf("error filling module data: %v", err)
	}
	// TODO: run module rules
	if err = writeLockFile(wsDir, ctx); err != nil {
		return fmt.Errorf("error writing lockfile: %v", err)
	}
	if err = writeWorkspaceFile(wsDir, ctx); err != nil {
		return fmt.Errorf("error writing workspace file: %v", err)
	}
	return nil
}

func fillModuleData(ctx *context) error {
	// For each module in the dep graph, decide what its repo name should be. (which is the module name, unless
	// the root module's MODULE.bazel file specifies a different repo_name for it)
	for moduleKey, module := range ctx.depGraph {
		module.RepoName = moduleKey.Name
	}
	rootModule := ctx.depGraph[ModuleKey{ctx.rootModuleName, ""}]
	rootModule.RepoName = ""
	for repoName, depKey := range rootModule.Deps {
		ctx.depGraph[depKey].RepoName = repoName
	}

	// Grab the fetcher for modules whose fetcher hasn't been populated yet.
	for moduleKey, module := range ctx.depGraph {
		if module.RepoName == "" || module.Fetcher != nil {
			continue
		}
		var err error
		module.Fetcher, err = module.Reg.GetFetcher(moduleKey.Name, moduleKey.Version)
		if err != nil {
			return err
		}
	}

	return nil
}

func writeLockFile(wsDir string, ctx *context) error {
	// TODO: Move lockfile struct definitions into a new module.
	type Repo struct {
		Fetcher fetch.Wrapper
	}
	type LockFile struct {
		Repos map[string]Repo
	}
	l := LockFile{Repos: make(map[string]Repo)}

	for _, module := range ctx.depGraph {
		if module.RepoName == "" {
			continue
		}
		l.Repos[module.RepoName] = Repo{
			Fetcher: fetch.Wrap(module.Fetcher),
		}
	}

	bytes, err := json.MarshalIndent(l, "", "  ")
	if err != nil {
		return err
	}
	return ioutil.WriteFile(filepath.Join(wsDir, "bzlmod.lock"), bytes, 0644)
}

const workspaceTemplate = `# This file is automatically generated by bzlmod
workspace({{if .WsName}}
    name = "{{.WsName}}",{{end}}
    watch_files = { "MODULE.bazel": "{{.Integrity}}" },
    refresh_command = ["bzlmod", "resolve"],
)
{{range $name, $repo := .Repos}}
repo(
    name = "{{$name}}",
    fetch_command = ["bzlmod", "fetch", "{{$name}}"],
    fingerprint = "{{$repo.Fingerprint}}",{{if $repo.Deps}}
    repo_deps = { {{- range $key, $value := $repo.Deps }}
        "{{$key}}": "{{$value}}",{{end}}
    },{{end}}
)
{{end}}`

func writeWorkspaceFile(wsDir string, ctx *context) error {
	type repoData struct {
		Fingerprint string
		Deps        map[string]string
	}
	data := struct {
		WsName    string
		Integrity string
		Repos     map[string]repoData
	}{
		WsName:    ctx.rootModuleName,
		Integrity: "sha256-fakevalue", // TODO
		Repos:     make(map[string]repoData),
	}

	// Now fill the data struct.
	for _, module := range ctx.depGraph {
		if module.RepoName == "" {
			continue
		}
		repoDeps := make(map[string]string)
		data.Repos[module.RepoName] = repoData{
			Fingerprint: "fakefingerprint", // TODO
			Deps:        repoDeps,
		}
		for depRepoName, depKey := range module.Deps {
			repoDeps[depRepoName] = ctx.depGraph[depKey].RepoName
		}
	}

	t := template.Must(template.New("workspace").Parse(workspaceTemplate))
	f, err := os.Create(filepath.Join(wsDir, "WORKSPACE"))
	if err != nil {
		return err
	}
	if err = t.Execute(f, data); err != nil {
		return err
	}
	return nil
}
