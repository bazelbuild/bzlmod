package resolve

import (
	"encoding/json"
	"fmt"
	"github.com/bazelbuild/bzlmod/common"
	"github.com/bazelbuild/bzlmod/fetch"
	"github.com/bazelbuild/bzlmod/lockfile"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
)

type context struct {
	rootModuleName       string
	depGraph             DepGraph
	overrideSet          OverrideSet
	moduleBazelIntegrity string
	vendorDir            string
}

func Resolve(wsDir string, vendorDir string, registries []string) error {
	ctx, err := runDiscovery(wsDir, vendorDir, registries)
	if err != nil {
		return fmt.Errorf("error during discovery: %v", err)
	}
	if err = runSelection(ctx); err != nil {
		return fmt.Errorf("error running selection: %v", err)
	}
	if err = fillModuleData(ctx); err != nil {
		return fmt.Errorf("error filling module data: %v", err)
	}
	// TODO: run module rules
	if err = writeLockFile(wsDir, ctx); err != nil {
		return fmt.Errorf("error writing lockfile: %v", err)
	}
	if err = writeWorkspaceFile(wsDir, ctx); err != nil {
		return fmt.Errorf("error writing workspace file: %v", err)
	}
	return nil
}

func fillModuleData(ctx *context) error {
	// For each module in the dep graph, decide what its repo name should be. (which is the module name, unless
	// the root module's MODULE.bazel file specifies a different repo_name for it)
	for moduleKey, module := range ctx.depGraph {
		module.RepoName = moduleKey.Name
	}
	rootModule := ctx.depGraph[common.ModuleKey{ctx.rootModuleName, ""}]
	rootModule.RepoName = ""
	for repoName, depKey := range rootModule.Deps {
		ctx.depGraph[depKey].RepoName = repoName
	}

	// Grab the fetcher for modules whose fetcher hasn't been populated yet.
	for moduleKey, module := range ctx.depGraph {
		if module.RepoName == "" || module.Fetcher != nil {
			continue
		}
		var err error
		module.Fetcher, err = module.Reg.GetFetcher(moduleKey)
		if err != nil {
			return err
		}
		// We may need to apply an extra set of patches here if this module is overridden with more patches.
		if o, ok := ctx.overrideSet[moduleKey.Name].(SingleVersionOverride); ok {
			if err = module.Fetcher.AppendPatches(o.Patches); err != nil {
				return err
			}
		}
	}

	return nil
}

func writeLockFile(wsDir string, ctx *context) error {
	ws := lockfile.NewWorkspace()
	ws.VendorDir = ctx.vendorDir

	for _, module := range ctx.depGraph {
		if module.RepoName == "" {
			continue
		}
		ws.Repos[module.RepoName] = &lockfile.Repo{
			Fetcher: fetch.Wrap(module.Fetcher),
		}
	}

	bytes, err := json.MarshalIndent(ws, "", "  ")
	if err != nil {
		return err
	}
	return ioutil.WriteFile(filepath.Join(wsDir, lockfile.FileName), bytes, 0644)
}

const workspaceTemplate = `# This file is automatically generated by bzlmod
workspace({{if .WsName}}
    name = "{{.WsName}}",{{end}}
    watch_files = { "MODULE.bazel": "{{.Integrity}}" },
    refresh_command = ["bzlmod", "resolve"],
)
{{range $name, $repo := .Repos}}
repo(
    name = "{{$name}}",
    fetch_command = ["bzlmod", "fetch", "{{$name}}"],
    fingerprint = "{{$repo.Fingerprint}}",{{if $repo.Deps}}
    repo_deps = { {{- range $key, $value := $repo.Deps }}
        "{{$key}}": "{{$value}}",{{end}}
    },{{end}}
)
{{end}}`

func writeWorkspaceFile(wsDir string, ctx *context) error {
	type repoData struct {
		Fingerprint string
		Deps        map[string]string
	}
	data := struct {
		WsName    string
		Integrity string
		Repos     map[string]repoData
	}{
		WsName:    ctx.rootModuleName,
		Integrity: ctx.moduleBazelIntegrity,
		Repos:     make(map[string]repoData),
	}

	// Now fill the data struct.
	for _, module := range ctx.depGraph {
		if module.RepoName == "" {
			continue
		}
		repoDeps := make(map[string]string)
		data.Repos[module.RepoName] = repoData{
			Fingerprint: module.Fetcher.Fingerprint(),
			Deps:        repoDeps,
		}
		for depRepoName, depKey := range module.Deps {
			repoDeps[depRepoName] = ctx.depGraph[depKey].RepoName
		}
	}

	t := template.Must(template.New("workspace").Parse(workspaceTemplate))
	f, err := os.Create(filepath.Join(wsDir, "WORKSPACE"))
	if err != nil {
		return err
	}
	if err = t.Execute(f, data); err != nil {
		return err
	}
	return nil
}
